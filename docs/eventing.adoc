
= Knative Eventing client support
Roland Huß <rhuss@redhat.com>; Matthias Wessendorf <mwessendorf@redhat.com>
v0.1.0, 2019-07-02

This document is a suggestion how support for Knative Eventing can be implemented within `kn`.
This support should be on the same level and with the same user experience as the existing support for Knative Serving.

It is important to note that we approach the problem space upside down.
I.e. everything described here is based on the concept included in Knative Eventing 0.7.0.
and could be implemented immediately.

Also, this approach tries to map to the scenarios described in this <<eventing-ux-issue,GitHub issue>> and this <<eventing-ux-scenarios,scenario document>> where usage scenarios are the foundation,

Before describing the use case and a possible implementation we will have a look to the identified Eventing roles in <<roles>>.

The following section then talks about the various <<abstraction,abstraction levels>> and what balance is targeted by this document.

Concrete use case with sample kn usage are describe in <<use-cases>>.

As we will see in the use case section, there are subtle differences compared to Knative Serving as Knative Eventing as an _open_ API which can be extended with custom types (CRDs) whereas Knative Serving consists of a closed set of entities (`Service`, `Configuration`, `Revision`, `Route`) described by a fixed set of CRDs.
A suggestion how to deal with the dynamic nature of <<importers>> and <<channels>> on the client side is proposed in <<custom-types>>, which proposes a specific plugin architecture for managing importers and channels.

Finally, a set of <<examples>> for a managing importers like an (already contributed) <<example-kafka-source, KafkaSource>> and an (imaginary) <<twitter-source, TwitterSource>> tries to illustrate they implementation suggestion for dynamic types.

[[roles]]
== Roles

For Knative Eventing there are typically three roles for which use cases can be classified:

* **Administrators** install Knative on a target platform like Kubernetes. Administrators are responsible for registering the Knative Eventing core CRDs and installing operators for watching those. Administrator are also responsible for installing any importer (aka source) and channel **types** (CRD and controllers) so that _Integrators_ can create integration and channel **instances** with a specific configuration. The can be more than one instance for each type (e.g. differnent Kafka importers for different Kafka topics)

* **Integrators** are responsible for managing importer and channel instances out of the list of installed type. They are also responsible for creating brokers, which reference specific channels.

* **Developers** are using the importers, channels and brokers by linking them together, potentially also with Knative services created by the developer.

Of course a single person can fulfill multiple roles.
The scope of this document is suggestion a concrete kn support for the roles of an _Integrator_ and _Developer_. _Administrators_ are out of scope for the Knative client as the install Knative in a platform specific way.

[[abstraction]]
== Level of Abstraction

Every feature of Knative Eventing and Serving can be used with a general purpose CLI tool like `kubectl`.
However, it is the goal of the specialized `kn` CLI tool to make common use cases easy to perform.
Therefor `kn` takes a somewhat opinionated approach, and restricts certain variations and combinations (like creating `Routes` directly with kn in favor of doing everything via the `Service`).

The question is how much abstracted the core Knative concepts should be.
This is not a discrete choice but a spectrum with exposing Knative CRs directly on the one side, and using a complete new vocabulary specific to `kn` on the other side.

Let's have a quick look on both ends of the spectrum:

* [[abstraction-crs]] **Direct CR management** only provides a thin layer of creating a CR diretly. For example `kn service create myservice --image myorga/myservice:1.0` will just create a single Knative Serving `Service`. This already provides much value as it encapsulates already domain knowledge how to create the underlying CR. A good example here are the option `--concurrency-limit` and `--concurrency-target` which are kind of hard and soft limits for when to trigger an autoscaling event, but on the CR the end up in different places (direct CR field vs. provided as annotation)

* [[abstraction-use-case]] **Use-case backed interface** encapsulates the management of Knative custom resources behind an opinionated user interface. Examples for this higher-order abstractions are:
** `kn rollout --strategy blue-green` for creating
** `kn rollout --strategy canary --canary-target=2 --image=myservice:2.0` for creating a new revision with for a new version with a target of %2 procent for the canary.
** `kn connect --source github://secretname@github.com/user/helloworld --select ... --destination service://myservice` for connecting an importer to a broker, creating a trigger with `--select` which references a Knative service `myservice` as sink.

`kn` takes an approach somewhat inb etween, leaning towards to the _use-case backed interface_ but also allows direct CR management where needed.

[[use-cases]]
== Use Cases

In the following and depending on which side of the <<abstraction,spectrum of abstractions>> we are moving, the full set of CRUD verbs are supported when managing simple resources:

create <name>::
  Create an entity with _<name>_
update <name>::
  Update entity with _<name>_
show <name>::
  Show details of the entity _<name>_
delete <name>::
  Delete entity <name>
list <prefix>::
  List entities. If _<name-prefix>_ is given, filter the entity names on this prefix.

In the following use cases we refer to this set as "CRUD operations".

[[use-case-integrator]]
=== Integrator use cases

The following use cases can be categorized by this epic use case below.
So they are all about setting up the topology which includes brokers, channels and the importers that then can be used by a _Developer_.

[quote]
____
As an _Integrator_ I want to manage importers (sources) and the infrastructure elements like brokers and channels to set up the eventing topology.
____

[[importers]]
==== Importers

[[brokers]]
==== Brokers

[[channels]]
==== Channels

Beside that channels can be created implicitely via a Broker, channels also can be created manually by an _Integrator_ so that a _Developer_ can use them when subscribing to them (by creating connections as described in

.List all channel types
[quote]
____
As an _Integrator_ I want to find all channel types which are available by a given Knative installation
____

.Example
[source]
----
kn channel types

TYPE                DESCRIPTION
in-memory           Non-persistent in memory channel (default)
kafka               Kafka backed channel
pubsub              Google Cloud pub-sub
natss               NATSS
activemq            ActiceMQ backed channel
----

Only those types which can be really used for the given Knative installation must show up here.
For the four directly supported channel types _in-memory_, _kafka_, _pubsub_ and _natts_ the corresponding cluster features needs to be enabled.
For custom channel types like _activemq_ in this example, also a local **channel plugin** needs to be present.
See <<custom-types>> for more details how channel type detection and channel plugins could work.

.Create a new channel
[quote]
____
As an _Integrator_ I want to create a channel with a specified type
____

Allows  channel-type specific creation options
Get the channel options for external channel implementations. This might be implemented with a plugin model for channel plugins which are external programs and which follow a plugin SPI for
Getting the CRD kind which this channel plugin manages
A name which can be used as a label when listing all available channel types.
Getting a textual description of all options supported by the channel plugin which is returned to the used if asking for help
Well-known channel types (in-memory, kafka, pubsub, natss) are hardcoded in kn, but for the users its opaque whether a he creates a channel from such a well-known type for from a channel plugin

.List all channels
[quote]
____
I want to list all channels
____

.Show channel details
[quote]
____
I want to see the details of a channel
____

Triggers attached to the channel
Broker which uses the channel

.Remove a channel
[quote]
____
I want to remove a channel
____

Check for triggers attached to the channel and prevent deletion by default if used
--force for removing channel unconditionally
--recursive removing channel + triggers referring this channel

[[use-case-developer]]
=== Developer use cases

The developer is the user of the eventing topology.
She creates services (presumably Knative Serving services) and connects them importers either directly, via a channel or via a broker.

[quote]
____
As a _Developer_ I want to use the eventing topology to receive events for which I can register my services with filtering and chaining.
____

[[connections]]
==== Service connections

There are several ways how a service can be registered for retrieving cloud events: direct, via broker or via subscription.
Depending on the mode, custom resources created looks quite differently as well as the preconditions.
However, this should not matter for the UI as they all serve the same use case, but with different capabilities.

.Connect a service for receiving events
[quote]
____
As a _Developer_ I want to connect a service to the eventing infrastructure.
____

[source]
----
# Connect a service directly to an importer, giving it a name
$ kn connection create myconnection --service myservice --importer k8sapievents

# Alternative syntax:
$ kn connection create myconnection --service myservice --target importer:k8sapievents

# Alternative syntax (starting from "service")
$ kn service connect myservice --conection myconnection --target importer:k8sapievents

# Connect a service to a broker with a trigger and the given filter
$ kn service connect myservice --broker default --filter <filter-expression>

Connection myservice-001 has been created.
----

Depending on the arguments, the service is connected to the event system in different ways:

* Directly to an Importer (`--importer <importer-name>` or `--target importer:<importer-name>`)
* With a subscription to a channel (`--channel <channel-name>` or `--target channel:<channel-name>`)
* With a trigger connected to a broker (`--broker <broker-name>` or `--target broker:<broker-name>`)

A connection gets by default a randomly created name, with the service name as prefix. This name is stored as part of the metadata of the created entities (directly on the `Importer`, on the `Subscription` or on the `Trigger` )

.Update a connection to an event producer
[quote]
____
As a _Developer_ I want to update a connection
____

[source]
----
$ kn connection update myconnection  --filter <new filter>
----

NOTE: Not sure if this is really needed and whether removing/adding such a connection would not be enough.

.Show details of a connection
[quote]
____
As a _Developer_ I want to see the details of a connection
____

[source]
----
$ kn connection show myconnection

....
----

.List all connections
[quote]
____
As a _Developer_ I want to list all connections
____

[source]
----
# List all connections
$ kn connections list

NAME             SERVICE       TYPE       BROKER   FILTER  CHANNEL
myservice-001    myservice     importer
myservice-002    myservice     broker     default  ...     tempchannel
mysecondsrv-001  mysecondsrv                               mychannel
....

# List only connections which are attached to this service
$ kn connections list --service myservice
----

.Delete a connection
[quote]
____
As a _Developer_ I want to delete a connection.
____

[source]
----
# Delete the connection
$ kn service delete-connection myconnection
----

[NOTE]
====
For creating a connection we could also piggy-back on the `service` command group as an (additional ?) alternative, leading to commands like `kn service connect myservice1 --broker mybroker`. The same might apply for the other subscription use cases, too. The connection's name would be auto generated from service name or provided via --name
====

[[sequences]]
==== Sequences

[[custom-types]]
== Custom types

// This should be done by querying for CRDs with a category “channel”
//As querying for CRDs is a K8s concept, it would be helpful if getting the list of available channel types from the Knative eventing API
//Beside checking available CRDs also check whether a corresponding channel plugin is available locally a long with a download URL when it is not.

Knative Eventing can be easily extended with new channel and importer types by introducing CRDs and install controllers which evaluate instances of these CRDs.

The kn client can easily query for all CRDs and match on all CRDs with a category of "knative" and "channel":

[source, yaml]
----
kind: CustomResourceDefinition
spec:
  group: messaging.knative.dev
  names:
    categories:
    - all
    - knative
    - messaging
    - channel
    kind: InMemoryChannel
----

The list of returned CRDs are the channels that can be used for creating new channels, whereby it is assumed that a corresponding controller has been installed on the server side, too.

However, since each channel type supports different configuration options, a client side mechanism allows user to provide these configuration as command line options/flags.
An alternative would be to evaluate the CRDs openAPI schema to provide a general way to query for the options. However such a generic mechanism never can provide the same UX as custom tailored client side extension.

For well known types (like InMemoryChannel) the channel specific features are well known and can be directly supported by kn. For custom provided types a plugin mechanism is required.

Such a channel plugin is an external binary placed in a well location (e.g. `~/.kn/plugins/channels/`) and fulfill a contract like:

The name of the binary reflects the type that should be used in `kn channel create --type <channel-type>`
The following commands given as arguments are supported by the executable

.Plugin contract for importer and channel plugins
|===
| Command | Description

|
| Print out the CRD coordinates which connects this plugin to the CRD it is responsible for. Can be a JSON structure with the kind, group and api version and a textual description of the channel type

| `help`
| A description of the supported options for create/update. This text will be integrated in “kn” help output.

| `create`
| Create a resource of this kind. The provided command line arguments are handed through directly to the plugin. The first argument will be the name of the resource creazted, the rest are options specific for this importer or channel.

| `update`
| Upate a plugin managed resource. The syntax is the same as for `create` except that a resource for the given name should be updated.

| `describe`
| Print out a human readable description for the channel or importer.
|===

If for one channel is either the CRD is missing or the client side plugin, then this channel type is disabled.

For the user it should not matter whether the channel management is hardcoded in the kn binary or provided by a channel plugin. I.e. when listing all available channel types both types (internally provided, via plugin) are presented on the same level.

The same mechanism should be implemented for importer plugins for handling custom importers which are represented by CRDs in the same way as channels.

[[importers]]
=== Importers

[[channels]]
=== Channels

[[examples]]
== Examples

[[example-importer-cronjob]]
=== CronJob Importer

[[example-importer-twitter]]
=== Twitter Importer Plugin


[[references]]
== References

* https://github.com/knative/client/issues/217[Kn Client issue] tracking eventing integration
* [[eventing-ux-issue]] https://github.com/knative/eventing/issues/1381[Kn Eventing issue] tracking UI/UX
* [[eventing-ux-scenarios]] https://docs.google.com/document/d/1DpiSL2dUcYS2n7yXOIG5LJwyIC1lY9q_W8-56U1SvKM/edit?hl=en#[Scenarios for Knative Eventing]
