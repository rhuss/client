
= Knative Eventing client support
Roland Hu√ü <rhuss@redhat.com>; Matthias Wessendorf <mwessendorf@redhat.com>
v0.1.0, 2019-07-02
:icons: font
:toc:

This document is a suggestion how support for Knative Eventing can be implemented within `kn`.
This support should be on the same level and with the same user experience as the existing support for Knative Serving.

It is important to note that we approach the problem space upside down.
I.e. everything described here is based on the concept included in Knative Eventing 0.7.0.
and could be implemented immediately.

Also, this approach tries to map to the scenarios described in this <<eventing-ux-issue,GitHub issue>> and this <<eventing-ux-scenarios,scenario document>> where usage scenarios are the foundation,

Before describing the use case and a possible implementation we will have a look to the identified Eventing roles in <<roles>>.

The following section then talks about the various <<abstraction,abstraction levels>> and what balance is targeted by this document.

Concrete use case with sample kn usage are describe in <<use-cases>>.

As we will see in the use case section, there are subtle differences compared to Knative Serving as Knative Eventing as an _open_ API which can be extended with custom types (CRDs) whereas Knative Serving consists of a closed set of entities (`Service`, `Configuration`, `Revision`, `Route`) described by a fixed set of CRDs.
A suggestion how to deal with the dynamic nature of <<importers>> and <<channels>> on the client side is proposed in <<custom-types>>, which proposes a specific plugin architecture for managing importers and channels.

Finally, a set of <<examples>> for a managing importers like an (already contributed) <<example-kafka-source, KafkaSource>> and an (imaginary) <<twitter-source, TwitterSource>> tries to illustrate they implementation suggestion for dynamic types.

[[summary]]
== Summary

* Introduce roles

`kn` takes an approach somewhat in between but with a clear tendency with respect to each use-case's role:

* For _Integrators_ the full flexibility should be available, so that the eventing topology can be setup flexibly. The UI for _Integrator_ use cases is a thin wrapper over the underlying custom resources (<<channels>>, <<importers>>, <<broker>>). The benefit here is not only a simplified resource management but also how `kn` can deal with custom implementations of importers and channels. For this a very specific plugin architecture is suggested. See <<custom-types>> for more information about this extension hook.

* For _Developers_ a more opinionated approach is taken, shielding the developer from direct resource management. There are currently three different ways how a service can be registered for events: Direct linkage to an importer, subscription to a channel, or subscription to a broker with a trigger. All of these different ways are to be shielded behind a common UX. In <<connections>> a suggestion is made how this can be achieved with a noun "connection" that fits into the general '_<noun> <verb>_' scheme of `kn` and is not directly connected to any backing CR. For <<sequences>> a workflow is suggested to build up such a sequence of connected transforming services.

To summarize this summary :) there are three key take-aways from this document:

[cols="1,10"]
|===
| üé•
| Differentiate between the **_Integrator_** and **_Developer_** role.

| üîå
| How to **extend** importers and channels with types that are initially unknown to `kn`

| üéÅ
| How to help _Developers_ with an **opinionated way** to connect their services to the event topology.
|===

Let's have a look on the identified roles first.

[[roles]]
== Roles

For Knative Eventing there are typically three roles for which use cases can be classified:

* **Administrators** install Knative on a target platform like Kubernetes. Administrators are responsible for registering the Knative Eventing core CRDs and installing operators for watching those. Administrator are also responsible for installing any importer (aka source) and channel **types** (CRD and controllers) so that _Integrators_ can create integration and channel **instances** with a specific configuration. The can be more than one instance for each type (e.g. differnent Kafka importers for different Kafka topics)

* **Integrators** are responsible for managing importer and channel instances out of the list of installed type. They are also responsible for creating brokers, which reference specific channels.

* **Developers** are using the importers, channels and brokers by linking them together, potentially also with Knative services created by the developer.

Of course a single person can fulfill multiple roles.
The scope of this document is suggestion a concrete kn support for the roles of an _Integrator_ and _Developer_. _Administrators_ are out of scope for the Knative client as the install Knative in a platform specific way.

[[abstraction]]
== Level of Abstraction

Every feature of Knative Eventing and Serving can be used with a general purpose CLI tool like `kubectl`.
However, it is the goal of the specialized `kn` CLI tool to make common use cases easy to perform.
Therefor `kn` takes a somewhat opinionated approach, and restricts certain variations and combinations (like creating `Routes` directly with kn in favor of doing everything via the `Service`).

The question is how much abstracted the core Knative concepts should be.
This is not a discrete choice but a spectrum with exposing Knative CRs directly on the one side, and using a complete new vocabulary specific to `kn` on the other side.

Let's have a quick look on both ends of the spectrum:

* [[abstraction-crs]] **Direct resource management** only provides a thin layer of creating a CR diretly. For example `kn service create myservice --image myorga/myservice:1.0` will just create a single Knative Serving `Service`. This already provides much value as it encapsulates already domain knowledge how to create the underlying CR. A good example here are the option `--concurrency-limit` and `--concurrency-target` which are kind of hard and soft limits for when to trigger an autoscaling event, but on the CR the end up in different places (direct CR field vs. provided as annotation). _Integrator_ use cases tend toward this end.

* [[abstraction-use-case]] **Use-case backed interface** encapsulates the management of Knative custom resources behind an opinionated user interface. Examples for this higher-order abstractions are:
** `kn rollout --strategy blue-green` for creating
** `kn rollout --strategy canary --canary-target=2 --image=myservice:2.0` for creating a new revision with for a new version with a target of %2 procent for the canary.
** `kn connect --source github://secretname@github.com/user/helloworld --select ... --destination service://myservice` for connecting an importer to a broker, creating a trigger with `--select` which references a Knative service `myservice` as sink.
+
_Developer_ use cases are opinionated and make the underlying custom resources more or less opaque.

[[use-cases]]
== Use Cases

All the use case in this section are crafted with this `kn` UI scheme in mind:

kn <noun> create <name>:: Create a _<noun>_ identified by _<name>_
kn <noun> update <name>:: Update a _<noun>_ identified by _<name>_
kn <noun> show <name>:: Show details of the _<noun>_ instance with name _<name>_ footnote:[This is currently still named as _describe_ but under discussion to be renamed.]
kn <noun> delete <name>:: Delete an instance of _<noun>_  with _<name>_
kn <noun> list <prefix>:: List entities. If _<name-prefix>_ is given, filter the entity names on this prefix.

_<noun>_ can be either directly reflecting the underlying Knative custom resource (typical for _Integrator_ based use cases) or more abstract, developer oriented, concepts like the proposed `connection` which describes any connection from a `service` to the event backend. See <<connections>> for details.

Also, when there is a (hierarchical) relationship between _<nouns>_ (like between `service` and `revision`) special option might filter on the high-level _<noun>_ (like in `kn revision list --service myservice`).

This scheme which has been applied successfully for managine Knative serving should be preserved for Knatice eventing support as well.

It is to be discussed whether the scheme should be relaxed for supporting developer workflows more naturally, eg. like in

```
kn rollout
kn rollback
kn connect <service> --broker mybroker
kn disconnect <service> --all
kn split revision1:10% revision2:90%
```

so, in the general fourm `kn <verb>` where verb concretely refers a developer use case which is not mapped 1:1 to entities (so more of category _Use-case backed interface_)

NOTE: In the example above `route` is used as a verb, which clashes with the Knative serving custom resource `Route`.

And of course a mixed format could be imaginable as well. E.g. creating and removing connections with `kn connect` and `kn disconnect`, but listing, updating and showing connections with `kn connection list`, `kn connection update` and `kn connection show`


[[use-case-integrator]]
=== Integrator use cases

The following use cases can be categorized by this epic use case below.
So they are all about setting up the topology which includes brokers, channels and the importers that then can be used by a _Developer_.

**As an _Integrator_ I want to manage importers (sources) and the infrastructure elements like brokers and channels to set up the eventing topology.**

The following use cases are a break down, how the _eventing topology_ can actually be managed by directly managing the underlying Knative eventing resources.

[[channels]]
==== Channels

Channels are used for connecting importers/source to services and provide the backbone for the eventing system.
They can be created implicitely via brokers, but the can also be created directly by _Integrators_ so a _Developer_ can subscribe a service to it.

A channel has a certain type which determines how events are persisted and distributed.
There is a set of predefined types but not all available out of the box on every installation of Knative eventing.
The only channel type that is always available is an `in-memory` type.
Other types, like `kafka` for a Kafka backed event transport, needs extra installation efforts by an _Administrator_.
In addition _Administrators_ can introduce be new custom channels which are not known in advance by `kn`.
In order to use these custom channels a plugin architecture is propose in <<custom-types>>.

One important use case for the _Integrator_ is to list all available types (installed ootb and custom) that can be used for creating a channel.
Let's have a look at this use case first.

===== List all channel types

**As an _Integrator_ I want to find all channel types which are available by a given Knative installation**

.Example
[source]
----
# List all channel types which are installed on the cluster and for
# which client support is available
$ kn channel types

TYPE                DESCRIPTION
in-memory           Non-persistent in memory channel (default)
kafka               Kafka backed channel
pubsub              Google Cloud pub-sub
natss               NATSS
activemq            ActiceMQ backed channel
----

Only those types which can be really used for the given Knative installation must show up here.
For the four directly supported channel types _in-memory_, _kafka_, _pubsub_ and _natts_ the corresponding cluster features needs to be enabled by the _Administrator_.
For custom channel types like e.g. the _activemq_ in this example, also a local **channel plugin** needs to be present.
See <<custom-types>> for more details how channel type detection and channel plugins are proposed to work.

===== Create a new channel

**As an _Integrator_ I want to create a channel with a specified type**

.Example
[source]
----
$ kn channel create mychannel --type kafka --kafka
----

The `channel create` command creates directly a channel with the given type.
If no type is given then the default type is used (typically `in-memory`, but depends on the cluster configuration).




ecific creation options
Get the channel options for external channel implementations. This might be implemented with a plugin model for channel plugins which are external programs and which follow a plugin SPI for
Getting the CRD kind which this channel plugin manages
A name which can be used as a label when listing all available channel types.
Getting a textual description of all options supported by the channel plugin which is returned to the used if asking for help
Well-known channel types (in-memory, kafka, pubsub, natss) are hardcoded in kn, but for the users its opaque whether a he creates a channel from such a well-known type for from a channel plugin

===== List all channels
**As an _Integrator_ and as a _Developer_ I want to list all channels**

===== Show channel details
**As an _Integrator_ and as a _Developer_ I want to see the details of a channel**

Triggers attached to the channel
Broker which uses the channel

===== Remove a channel
**As an _Integrator_ I want to remove a channel**

Check for triggers attached to the channel and prevent deletion by default if used
--force for removing channel unconditionally
--recursive removing channel + triggers referring this channel

[[importers]]
==== Importers

**As an _Integrator_ I want to find out all importer types available so that I know what importers I can create. **

NOTE: Importers are the new name of the resources formerly known as "Sources". Please see this https://github.com/knative/eventing/blob/master/docs/decisions/sources-to-importers.md[document] for the motivation for this naming change.

As there can be many custom importers, a similar concept like for various channel implementations should be used (see below)

**As an _Integrator_ I want to create a new importer so that a _Developer_ can use it**
Options specific to the importer type should be possible to be provided
Same UX like for channels wrt/ out-of-the-box provided importers and user supplied importers.
Optional reference to a Knative service used a sink

**As an _Integrator_ or _Developer_ I want to list all importers**

**As an _Integrator_ or _Developer_ I want to see the details of an importer**

Type
Configuration options
Usages (broker, sinks)

**As an _Integrator_ I want to delete an importer**

[[brokers]]
==== Brokers

**As an _Integrator_ I want to create a broker in a namespace so that a _Developer_ can use it**

**As an _Integrator_ or _Developer_ I want to list all brokers in a namespace**

**As an _Integrator_ or _Developer_ I want to see the details of a broker**

What channels are attached
Importers referencing the broker

**As an _Integrator_ I want to remove a broker**

Check for Importers using the broker, and prevent deletion of broker if in use
--force to delete nevertheless

[[use-case-developer]]
=== Developer use cases

The developer is the user of the eventing topology.
She creates services (presumably Knative Serving services) and connects them importers either directly, via a channel or via a broker.

**As a _Developer_ I want to use the eventing topology to receive events for which I can register my services with filtering and chaining.**

[[connections]]
==== Service connections

There are several ways how a service can be registered for retrieving cloud events: direct, via broker or via subscription.
Depending on the mode, custom resources created looks quite differently as well as the preconditions.
However, this should not matter for the UI as they all serve the same use case, but with different capabilities.

===== Connect a service for receiving events

**As a _Developer_ I want to connect a service to the eventing infrastructure.**

[source]
----
# Connect a service directly to an importer, giving it a name
$ kn connection create myconnection --service myservice --importer k8sapievents

# Alternative syntax:
$ kn connection create myconnection --service myservice --target importer:k8sapievents

# Alternative syntax (starting from "service")
$ kn service connect myservice --conection myconnection --target importer:k8sapievents

# Connect a service to a broker with a trigger and the given filter
$ kn service connect myservice --broker default --filter <filter-expression>

Connection myservice-001 has been created.
----

Depending on the arguments, the service is connected to the event system in different ways:

* Directly to an Importer (`--importer <importer-name>` or `--target importer:<importer-name>`)
* With a subscription to a channel (`--channel <channel-name>` or `--target channel:<channel-name>`)
* With a trigger connected to a broker (`--broker <broker-name>` or `--target broker:<broker-name>`)

A connection gets by default a randomly created name, with the service name as prefix. This name is stored as part of the metadata of the created entities (directly on the `Importer`, on the `Subscription` or on the `Trigger` )

===== Update a connection to an event producer

**As a _Developer_ I want to update a connection**

[source]
----
$ kn connection update myconnection  --filter <new filter>
----

===== Show details of a connection

**As a _Developer_ I want to see the details of a connection**

.Example
[source]
----
$ kn connection show myconnection

....
----

===== List all connections

**As a _Developer_ I want to list all connections**

[source]
----
# List all connections
$ kn connections list

NAME             SERVICE       TYPE       BROKER   FILTER  CHANNEL
myservice-001    myservice     importer
myservice-002    myservice     broker     default  ...     tempchannel
mysecondsrv-001  mysecondsrv                               mychannel
....

# List only connections which are attached to this service
$ kn connections list --service myservice
----

===== Delete a connection

**As a _Developer_ I want to delete a connection.**

[source]
----
# Delete the connection
$ kn service delete-connection myconnection
----

[NOTE]
====
For creating a connection we could also piggy-back on the `service` command group as an (additional ?) alternative, leading to commands like `kn service connect myservice1 --broker mybroker`. The same might apply for the other subscription use cases, too. The connection's name would be auto generated from service name or provided via --name
====

[[sequences]]
==== Sequences

**As a _Developer_ I want to interactively build up a sequence.**

* Interactive workflow by subsequent calls to an "append" or "insert" calls for adding transformer services.

**As a _Developer_ I want to update a sequence.**

**As a _Developer_ I want to list all sequences.**

**As a _Developer_ I want to remove a sequence.**

(with usage check)

**As a _Developer_ I want to see the details of a sequence**
List of all transformers contained in the sequence

[[custom-types]]
== Custom types

// This should be done by querying for CRDs with a category ‚Äúchannel‚Äù
//As querying for CRDs is a K8s concept, it would be helpful if getting the list of available channel types from the Knative eventing API
//Beside checking available CRDs also check whether a corresponding channel plugin is available locally a long with a download URL when it is not.

Knative Eventing can be easily extended with new channel and importer types by introducing CRDs and install controllers which evaluate instances of these CRDs.

The kn client can easily query for all CRDs and match on all CRDs with a category of "knative" and "channel":

[source, yaml]
----
kind: CustomResourceDefinition
spec:
  group: messaging.knative.dev
  names:
    categories:
    - all
    - knative
    - messaging
    - channel
    kind: InMemoryChannel
----

The list of returned CRDs are the channels that can be used for creating new channels, whereby it is assumed that a corresponding controller has been installed on the server side, too.

However, since each channel type supports different configuration options, a client side mechanism allows user to provide these configuration as command line options/flags.
An alternative would be to evaluate the CRDs openAPI schema to provide a general way to query for the options. However such a generic mechanism never can provide the same UX as custom tailored client side extension.

For well known types (like InMemoryChannel) the channel specific features are well known and can be directly supported by kn. For custom provided types a plugin mechanism is required.

Such a channel plugin is an external binary placed in a well location (e.g. `~/.kn/plugins/channels/`) and fulfill a contract like:

The name of the binary reflects the type that should be used in `kn channel create --type <channel-type>`
The following commands given as arguments are supported by the executable

.Plugin contract for importer and channel plugins
[cols="1,7"]
|===
| Command | Description

|
| Print out the CRD coordinates which connects this plugin to the CRD it is responsible for. Can be a JSON structure with the kind, group and api version and a textual description of the channel type

| `help`
| A description of the supported options for create/update. This text will be integrated in ‚Äúkn‚Äù help output.

| `create`
| Create a resource of this kind. The provided command line arguments are handed through directly to the plugin. The first argument will be the name of the resource creazted, the rest are options specific for this importer or channel.

| `update`
| Upate a plugin managed resource. The syntax is the same as for `create` except that a resource for the given name should be updated.

| `describe`
| Print out a human readable description for the channel or importer.
|===

If for one channel is either the CRD is missing or the client side plugin, then this channel type is disabled.

For the user it should not matter whether the channel management is hardcoded in the kn binary or provided by a channel plugin. I.e. when listing all available channel types both types (internally provided, via plugin) are presented on the same level.

The same mechanism should be implemented for importer plugins for handling custom importers which are represented by CRDs in the same way as channels.

[[examples]]
== Examples

[[example-importer-cronjob]]
=== CronJob Importer

[[example-importer-twitter]]
=== Twitter Importer Plugin

[[references]]
== References

* https://github.com/knative/client/issues/217[Kn Client issue] tracking eventing integration
* [[eventing-ux-issue]] https://github.com/knative/eventing/issues/1381[Kn Eventing issue] tracking UI/UX
* [[eventing-ux-scenarios]] https://docs.google.com/document/d/1DpiSL2dUcYS2n7yXOIG5LJwyIC1lY9q_W8-56U1SvKM/edit?hl=en#[Scenarios for Knative Eventing]
