
= Knative Eventing client support
Roland Hu√ü <rhuss@redhat.com>; Matthias Wessendorf <mwessendorf@redhat.com>
v0.1.0, 2019-07-04
:icons: font
:toc:


== tl;dr

This document is a suggestion how `kn` can support Knative eventing,
This support should be on the same level and with the same user experience as the existing support for Knative serving.

It is important to note that we approach the problem space upside down.
I.e. everything described here is based on the API of Knative eventing 0.7.0.
and could be implemented immediately without requiring changes on Knative eventing.

In this document we are trying to map the scenarios described in <<eventing-ux-issue,GitHub issue>> and <<eventing-ux-scenarios,scenario document>> to the roles we define here, which are slightly different.

The three key themes of this document are

[cols="1,10,3"]
|===
| üé•
| Introducing the **_Integrator_** and **_Developer_** role and how their use cases map to `kn` commands
| <<roles>>

| üîå
| How to **extend** importers and channels with custom types that are initially unknown to `kn`
| <<custom-types>>

| üéÅ
| How to help _Developers_ with an **opinionated way** to connect their services to the event topology.
| <<connections>>
|===


Before describing the use case and a possible implementation we will have a look to the identified Eventing roles in <<roles>>.

The following section then talks about the various <<abstraction,abstraction levels>> and what balance is targeted by this document.

Concrete use case with sample kn usage are describe in <<use-cases>>.

As we will see in the use case section, there are subtle differences compared to Knative Serving as Knative Eventing as an _open_ API which can be extended with custom types (CRDs) whereas Knative Serving consists of a closed set of entities (`Service`, `Configuration`, `Revision`, `Route`) described by a fixed set of CRDs.
A suggestion how to deal with the dynamic nature of <<importers>> and <<channels>> on the client side is proposed in <<custom-types>>, which proposes a specific plugin architecture for managing importers and channels.

Finally, a set of <<examples>> for a managing importers like an (already contributed) <<example-kafka-source, KafkaSource>> and an (imaginary) <<twitter-source, TwitterSource>> tries to illustrate they implementation suggestion for dynamic types.

[[summary]]
== Summary


[[roles]]
== Roles

For Knative Eventing there are typically three roles for which use cases can be classified:

* **Administrators** install Knative on a target platform like Kubernetes. Administrators are responsible for registering the Knative Eventing core CRDs and installing operators for watching those. Administrator are also responsible for installing any importer (aka source) and channel **types** (CRD and controllers) so that _Integrators_ can create integration and channel **instances** with a specific configuration. The can be more than one instance for each type (e.g. differnent Kafka importers for different Kafka topics)

* **Integrators** are responsible for managing importer and channel instances out of the list of installed type. They are also responsible for creating brokers, which reference specific channels.

* **Developers** are using the importers, channels and brokers by linking them together, potentially also with Knative services created by the developer.

Of course a single person can fulfill multiple roles.

The scope of this document is suggestion a concrete kn support for the roles of an _Integrator_ and _Developer_. _Administrators_ are out of scope for the Knative client as the install Knative in a platform specific way.

* For _Integrators_ the full flexibility should be available, so that the eventing topology can be setup flexibly. The UI for _Integrator_ use cases is a thin wrapper over the underlying custom resources (<<channels>>, <<importers>>, <<broker>>). The benefit here is not only a simplified resource management but also how `kn` can deal with custom implementations of importers and channels. For this a very specific plugin architecture is suggested. See <<custom-types>> for more information about this extension hook.

* For _Developers_ a more opinionated approach is taken, shielding the developer from direct resource management. There are currently three different ways how a service can be registered for events: Direct linkage to an importer, subscription to a channel, or subscription to a broker with a trigger. All of these different ways are to be shielded behind a common UX. In <<connections>> a suggestion is made how this can be achieved with a noun "connection" that fits into the general '_<noun> <verb>_' scheme of `kn` and is not directly connected to any backing CR. For <<sequences>> a workflow is suggested to build up such a sequence of connected transforming services.

The roles defined in the scenarios of <<eventing-ux-scenarios,scenario document>> can be mapped to the roles here like:

FaaS Scenario:: The developer role in the FaaS scenario is also the _Developer_ role in this document. It's a role which merely want to use a given infrastructure and event topology by connecting her services to event producers. See <<connections>> how the main developer use case is covered

Event-Driven Scenario:: The "event-producer developer" role maps to the _Integrator_ as it is the event-producer is responsible for managing importers and possibly brokers. See <<importers>>, <<channels>> and <<brokers>> for this roles' use cases. The "even-consumer developer" is the _Developer_ role here and is similar to the "developer" in the FaaS scenario as its about connection a service with an event producer (trigger, broker or directly via a channel subscription). <<connections>> (and also <<sequences>>) holds the use cases fro this scenario.

Black-box integration scenario:: The "central platform team" is represented by the _Integrator_ role for the provisioning part of the black-box software when it is about creating the importer resources. A "central platform team" very likely also has to perform tasks as an _Administrator_ to install the software's backend parts. The "developer" in this scenario then can use the importers installed by the _Integrator_ by managing <<connections>>).

[[abstraction]]
== Level of Abstraction

Every feature of Knative Eventing and Serving can be used with a general purpose CLI tool like `kubectl`.
However, it is the goal of the specialized `kn` CLI tool to make common use cases easy to perform.
Therefor `kn` takes a somewhat opinionated approach, and restricts certain variations and combinations (like creating `Routes` directly with kn in favor of doing everything via the `Service`).

The question is how much abstracted (or "opinionated") the core Knative concepts should be.
This is not a discrete choice but a spectrum with exposing Knative CRs directly on the one side, and using a complete new vocabulary specific to `kn` on the other side.

Let's have a quick look on both ends of the spectrum:

* [[abstraction-crs]] **Direct resource management** only provides a thin layer of creating a CR diretly. _Integrator_ use cases tend toward this end for managing the event topology with importers, channels or brokers.
* [[abstraction-use-case]] **Use-case backed interface** encapsulates the management of Knative custom resources behind an opinionated user interface. Examples for this higher-order abstractions are:
** `kn rollout --strategy blue-green` for creating
** `kn rollout --strategy canary --canary-target=2 --image=myservice:2.0` for creating a new revision with for a new version with a target of %2 procent for the canary.
** `kn connect --source github://secretname@github.com/user/helloworld --select ... --destination service://myservice` for connecting an importer to a broker, creating a trigger with `--select` which references a Knative service `myservice` as sink.
+
_Developer_ use cases are opinionated and make the underlying custom resources more or less opaque.

An interesting exception of this mapping here is the `kn service` command, which clearly serves a _Developer_ task. However, since a Knative `Service` is already a developer friendly abstraction and an umbrella resource for managing other resources (configuration, revisions, routes), it already has the proper abstraction to be used directly via `kn`. There is no similar umbrella object for Knative eventing. Although this is a _Developer_ task having this slight abstraction over managing a Service directly via `kubectl` has benefits, because it provides much value as it encapsulates domain knowledge how to create the underlying CR. A good example here are the option `--concurrency-limit` and `--concurrency-target` to `kn service create` which are kind of hard and soft limits for when to trigger an autoscaling event, but on the CR the end up in different places (direct CR field vs. provided as annotation)

[[use-cases]]
== Use Cases

All the use case in this section are crafted with this `kn` UI scheme in mind:

kn <noun> create <name>:: Create a _<noun>_ identified by _<name>_
kn <noun> update <name>:: Update a _<noun>_ identified by _<name>_
kn <noun> show <name>:: Show details of the _<noun>_ instance with name _<name>_ footnote:[This is currently still named as _describe_ but under discussion to be renamed.]
kn <noun> delete <name>:: Delete an instance of _<noun>_  with _<name>_
kn <noun> list <prefix>:: List entities. If _<name-prefix>_ is given, filter the entity names on this prefix.

_<noun>_ can be either directly reflecting the underlying Knative custom resource (typical for _Integrator_ based use cases) or more abstract, developer oriented, concepts like the proposed `connection` which describes any connection from a `service` to the event backend. See <<connections>> for details.

Also, when there is a (hierarchical) relationship between _<nouns>_ (like between `service` and `revision`) special option might filter on the high-level _<noun>_ (like in `kn revision list --service myservice`).

This scheme which has been applied successfully for managine Knative serving should be preserved for Knatice eventing support as well.

It is to be discussed whether the scheme should be relaxed for supporting developer workflows more naturally, eg. like in

```
kn rollout
kn rollback
kn connect <service> --broker mybroker
kn disconnect <service> --all
kn split revision1:10% revision2:90%
```

so, in the general form `kn <verb>` where verb concretely refers a developer use case which is not mapped 1:1 to entities (so more of category _Use-case backed interface_)

NOTE: In the example above `route` is used as a verb, which clashes with the Knative serving custom resource `Route`.

And of course a mixed format could be imaginable as well. E.g. creating and removing connections with `kn connect` and `kn disconnect`, but listing, updating and showing connections with `kn connection list`, `kn connection update` and `kn connection show`


[[use-case-integrator]]
=== Integrator use cases

The following use cases can be categorized by this epic use case below.
So they are all about setting up the topology which includes brokers, channels and the importers that then can be used by a _Developer_.

**As an _Integrator_ I want to manage importers (sources) and the infrastructure elements like brokers and channels to set up the eventing topology.**

The following use cases are a break down, how the _eventing topology_ can actually be managed by directly managing the underlying Knative eventing resources.

[[channels]]
==== Channels

Channels are used for connecting importers/source to services and provide the backbone for the eventing system.
They can be created implicitely via brokers, but the can also be created directly by _Integrators_ so a _Developer_ can subscribe a service to it.

A channel has a certain type which determines how events are persisted and distributed.
There is a set of predefined types but not all available out of the box on every installation of Knative eventing.
The only channel type that is always available is an `in-memory` type.
Other types, like `kafka` for a Kafka backed event transport, needs extra installation efforts by an _Administrator_.
In addition _Administrators_ can introduce be new custom channels which are not known in advance by `kn`.
In order to use these custom channels a plugin architecture is propose in <<custom-types>>.

One important use case for the _Integrator_ is to list all available types (installed well-known and custom types) that can be used for creating a channel.
Let's have a look at this use case first.

===== List all channel types

**As an _Integrator_ I want to find all channel types which are available by a given Knative installation**

.Example
[source]
----
# List all channel types which are installed on the cluster and for
# which client support is available
$ kn channel types

TYPE                DESCRIPTION
in-memory           Non-persistent in memory channel (default)
kafka               Kafka backed channel
pubsub              Google Cloud pub-sub
natss               NATSS
activemq            ActiceMQ backed channel
----

Only those types which can be really used for the given Knative installation must show up here.
For the four directly supported channel types _in-memory_, _kafka_, _pubsub_ and _natts_ the corresponding cluster features needs to be enabled by the _Administrator_.
For custom channel types like e.g. the _activemq_ in this example, also a local **channel plugin** needs to be present.
See <<custom-types>> for more details how channel type detection and channel plugins are proposed to work.

===== Create a new channel

**As an _Integrator_ I want to create a channel with a specified type**

.Example
[source]
----
$ kn channel create mychannel --type kafka --num-partitions=4 --replication-factor=3
----

The `channel create` command creates directly a channel with the given type.
If no type is given then the default type is used (typically `in-memory`, but depends on the cluster configuration).

In addition each type has specific configuration options (`--num-partitions` and `--replication-factor` in this example).
The client verifies which options are available depending whether its a well-known type or a custome type:

* For well-known types known to a vanilla Knative eventing installation, the possible options are included in kn.
* For custom types, which are backed by a custom channel plugin, the plugin is called to get the possible options. This process is described in <<custom-types>>.

For user though this difference doesn't matter so on the UI surface well-known and custom types are treated the same.

===== List all channels
**As an _Integrator_ and as a _Developer_ I want to list all channels**

.Example
[source]
-----
# List all channels for the current namespace
$ kn channel list

NAME             TYPE       BROKER  SUBSCRIBERS STATUS     INFLIGHT EVENTS
channel-1        kafka              2           Up         0        34326
myotherchannel   in-memory  default 4           Up
-----
This will list all channels available along with some summary description like the channel type, whether its created on behalf of a broker, the status, the number of subscriptions attached to this channel

If easily accessible some statistic informations about e.g. how many events has passed the channel would be nice or how many events have not been delivered yet.

===== Show channel details
**As an _Integrator_ and as a _Developer_ I want to see the details of a channel**

.Example
[source]
----
# Show specific details for a channel
$ kn channel show channel-1

Type: kafka
Broker: default
Subscribers:
- service1 [direct]

Triggers:
- myotherservice [event.type="bla"]
----

Any detail information available, also from related objects shoudl be shown here.
This command is also useful for _Developers_ as it helps in understanding the event topology.

===== Remove a channel
**As an _Integrator_ I want to remove a channel**

.Example
[source]
----
# Remove a channel but check whether its in use
$ kn channel remove channel-1
----

This command will remove a named channel, but only those which are not managed by a broker.
Also it should be checked whether the channel has some active subscriptions.
If this is the case then by default an error must be returned.
However an _Integrator_ can use `--force` to remove the channel *and* any active subscriptions.

[[importers]]
==== Importers

NOTE: Importers are the new name of the resources formerly known as "Sources". Please see this https://github.com/knative/eventing/blob/master/docs/decisions/sources-to-importers.md[document] for the motivation for this naming change.

Importers are there to pump events into the eventing topology.
Each importer has a specific type, much like channels.
In fact, from an implementation's point of view importers can be treated the same as channels.
And also from an UX point of view, the user interface for both can be nearly the same.
But let's have a look.

===== List all importer types

**As an _Integrator_ I want to find out all importer types available so that I know what importers I can create. **

.Example
[source]
----
# List all well-know as well as custom importers
$ kn importer types

TYPE            DESCRIPTION
kafka           Kafka importer picking up event from a Topic
kubernetes-api  Import Kubernetes event
cron            Periodic event from a cron importer
twitter         Import tweets by user or search
----

As there can be well-known importers (e.g. kafka) but also custom importers (twitter)
As you can see, the situatuon is the same as for <<channels>>, so similar concept apply here as well.

For full details for how to handle custom types and seamless integrate with the well-known types can be found in <<custom-types>>.

===== Create an importer

**As an _Integrator_ I want to create a new importer so that a _Developer_ can use it**

.Example
[source]
----
# Create an importer which picks up Tweets mentioning "knative"
$ kn importer create twitter-knative --type twitter --search knative
----

The mandatory flag for an importer is `--type` which specifies the type to use.
The value given there must be one of the list as given by `kn importer types`.

All other options are specific to the importer's type, much like the type of a channel.

An addition could be to provide here already a `--service` to create the connection to a service, but for the sake of conciseness creation of this connection should be left to `kn connection create` (or `kn connect` if we opt for a verb based flow for _Developer_ use cases).

==== List importers

**As an _Integrator_ or _Developer_ I want to list all existing importers**

.Example
[source]
----
# List all created importers
$ kn importer list

NAME               TYPE         RESOURCE
twitter-knative    twitter      twittersource.importers.k8spatterns.io
all-seconds        cron         cronjobsources.sources.eventing.knative.dev
----

==== Show importer details

**As an _Integrator_ or _Developer_ I want to see the details of an importer**

.Example
[source]
----
# Show details for a specific importer
$ kn importer show twitter-knative

Name:            twitter-knative
Resource:        twittesource.importers.k8spatterns.io
Type:            twitter
Search:          knative
Last Checked:    2019-07-04 04:50:12

Broker:          default
Subscribers:
- ....

....
----

As expected `kn importer show` will show all details for an importer.
This is an human readable output, and specific to the importer's type.

==== Delete importer

**As an _Integrator_ I want to delete an importer**

.Example
[source]
----
# Delete an importer
$ kn delete importer twitter-knative
----

Deletion should check, whether this importer is still in use.
If so, an error shoudl be returned.
An _Integrator_ can still delete an importer with the option `--force`.
In this case all subscriptions should be removed as well.

[[brokers]]
==== Brokers

===== Create a broker
**As an _Integrator_ I want to create a broker in a namespace so that a _Developer_ can use it**

.Example
[source]
----
# Create a broker
$ kn broker create --provisioner gcp-pupsub
----

Creating a broker will create a resource of kind `Broker` with possible configurations fields offered as option, like `--provisioner` to specify the cluster channel provisioner for the channel template included  by the broker.

===== List all brokers
**As an _Integrator_ or _Developer_ I want to list all brokers in a namespace**

.Example
[source]
----
# Return an overview of all brokers installed
$ kn broker list

NAME      STATUS      SUBSCRIPTIONS
default   Up          4
mybroker  Up          2
----

As all list commands, it shoudl be possible to export the list of brokers in a machine readable format like `json` or `yaml` and it should be possible to filter on brokers to show (startdWith filtering).

==== Show details of a broker
**As an _Integrator_ or _Developer_ I want to see the details of a broker**

.Example
[source]
----
# Show the details of broker `mybroker`
$ kn broker show mybroker
Name: mybroker
Status: Up

Subscriptions:
- name: my-service-trigger
  type: dev.knative.foo.bar
  service: myservice
- name: other-trigger
  type: prod.knative.foo.bar
  service: prodservice

Importers:
- name: financial-kafka-source
  type: kafka
----

This command should reveal all details of the `Broker` resource itself, but also information about objects that are _referencing_ this broker, like the importers which feed events into this broker.

==== Deleting a broker
**As an _Integrator_ I want to delete a broker**

.Example
[source]
----
# Delete broker 'mybroker'
$ kn broker delete mybroker
----

Before deleting a broker, kn should check if the broker is still in use.
E.g. when ther are subscriptions to this broker via triggers, then kn should refuse to delete the broker.
However, when an option `--force` is given, then the broker and all triggers referencing this broker should be deleted.

[[use-case-developer]]
=== Developer use cases

The developer is the user of the eventing topology.
She creates services (presumably Knative serving services) and connects them importers either directly, via a channel or via a broker.

**As a _Developer_ I want to use the eventing topology to receive events for which I can register my services with filtering and chaining.**

[[connections]]
==== Service connections

There are several ways how a service can be registered for retrieving cloud events: direct, via broker or via subscription.
Depending on the mode, custom resources created looks quite differently as well as the preconditions.
However, this should not matter for the UI as they all serve the same use case, but with different capabilities.

===== Connect a service for receiving events

**As a _Developer_ I want to connect a service to the eventing infrastructure.**

[source]
----
# Connect a service directly to an importer, giving it a name
$ kn connection create myconnection --service myservice --importer k8sapievents

# Alternative syntax:
$ kn connection create myconnection --service myservice --target importer:k8sapievents

# Alternative syntax (starting from "service")
$ kn service connect myservice --conection myconnection --target importer:k8sapievents

# Connect a service to a broker with a trigger and the given filter
$ kn service connect myservice --broker default --filter <filter-expression>

Connection myservice-001 has been created.
----

Depending on the arguments, the service is connected to the event system in different ways:

* Directly to an Importer (`--importer <importer-name>` or `--target importer:<importer-name>`)
* With a subscription to a channel (`--channel <channel-name>` or `--target channel:<channel-name>`)
* With a trigger connected to a broker (`--broker <broker-name>` or `--target broker:<broker-name>`)

A connection gets by default a randomly created name, with the service name as prefix. This name is stored as part of the metadata of the created entities (directly on the `Importer`, on the `Subscription` or on the `Trigger` )

===== Update a connection to an event producer

**As a _Developer_ I want to update a connection**

[source]
----
$ kn connection update myconnection  --filter <new filter>
----

===== Show details of a connection

**As a _Developer_ I want to see the details of a connection**

.Example
[source]
----
$ kn connection show myconnection

....
----

===== List all connections

**As a _Developer_ I want to list all connections**

[source]
----
# List all connections
$ kn connections list

NAME             SERVICE       TYPE       BROKER   FILTER  CHANNEL
myservice-001    myservice     importer
myservice-002    myservice     broker     default  ...     tempchannel
mysecondsrv-001  mysecondsrv                               mychannel
....

# List only connections which are attached to this service
$ kn connections list --service myservice
----

===== Delete a connection

**As a _Developer_ I want to delete a connection.**

[source]
----
# Delete the connection
$ kn service delete-connection myconnection
----

[NOTE]
====
For creating a connection we could also piggy-back on the `service` command group as an (additional ?) alternative, leading to commands like `kn service connect myservice1 --broker mybroker`. The same might apply for the other subscription use cases, too. The connection's name would be auto generated from service name or provided via --name
====

[[sequences]]
==== Sequences

**As a _Developer_ I want to interactively build up a sequence.**

* Interactive workflow by subsequent calls to an "append" or "insert" calls for adding transformer services.

**As a _Developer_ I want to update a sequence.**

**As a _Developer_ I want to list all sequences.**

**As a _Developer_ I want to remove a sequence.**

(with usage check)

**As a _Developer_ I want to see the details of a sequence**
List of all transformers contained in the sequence

[[custom-types]]
== Custom types

// This should be done by querying for CRDs with a category ‚Äúchannel‚Äù
//As querying for CRDs is a K8s concept, it would be helpful if getting the list of available channel types from the Knative eventing API
//Beside checking available CRDs also check whether a corresponding channel plugin is available locally a long with a download URL when it is not.

Knative Eventing can be easily extended with new channel and importer types by introducing CRDs and install controllers which reconciles on instances of these CRDs.

The kn client can easily query for all CRDs and match on all CRDs with a category of "knative" and "channel":

[source, yaml]
----
kind: CustomResourceDefinition
spec:
  group: messaging.knative.dev
  names:
    categories:
    - all
    - knative
    - messaging
    - channel
    kind: InMemoryChannel
----

The list of returned CRDs are the channels that can be used for creating new channels, whereby it is assumed that a corresponding controller has been installed on the server side, too.

However, since each channel type supports different configuration options, a client side mechanism allows user to provide these configuration as command line options/flags.
An alternative would be to evaluate the CRDs openAPI schema to provide a general way to query for the options. However such a generic mechanism never can provide the same user experience as custom tailored client side extensions.

For well known types (like `InMemoryChannel`) the channel specific features are well known and can be directly supported by kn. For custom provided types a plugin mechanism is required.

Such a channel plugin is an external binary placed in a well location (e.g. `~/.kn/plugins/channels/` or `~/.kn/plugins/importers/`)

The name of the binary reflects the type that should be used in `kn channel create --type <channel-type>`

The following commands given as arguments have to be supported by such a custom type plugin exectutable:

.Plugin contract for importer and channel plugins
[cols="1,7"]
|===
| Command | Description

| `manifest`
| Print out the CRD coordinates which connects this plugin to the CRD it is responsible for. This Can be a JSON structure with the kind, group and api version and a textual description of the channel type. Also it should contain the list of possible options along with their descriptions so that a help message can be constructed.

| `create`
| Create a resource of this kind. The provided command line arguments are handed through directly to the plugin. The first argument will be the name of the resource to create, the rest are options specific for this importer or channel.

| `update`
| Upate a plugin managed resource. The syntax is the same as for `create` except that a resource for the given name should be updated.

| `describe`
| Print out a human readable description for an existing channel or importer.
|===

If for one channel is either the CRD is missing or the client side plugin, then this channel type is disabled.

For the user it should not matter whether the channel management is hardcoded in the kn binary or provided by a channel plugin. I.e. when listing all available channel types both types (internally provided, via plugin) are presented on the same level.

The same mechanism should be implemented for importer plugins for handling custom importers which are represented by CRDs in the same way as channels.

[NOTE]
=====
The type discovery by querying matching CRDs requires that Knative eventing exposes the API operation for list CRDs also in its own interface. If this is not possible, an alternative would be to do a pure client discovery by checking which plugins are installed. The combination of this list plus the list of well-known types is list of supported types of this client. A client however would need then check whether the corresponding CRDs are registered on the server side, which can be done by a direct 'list' for such resources and checking for errors.
=====

[[examples]]
== Examples

NOTE:: To be done

[[example-importer-cronjob]]
=== CronJob Importer

[[example-importer-twitter]]
=== Twitter Importer Plugin

[[references]]
== References

* https://github.com/knative/client/issues/217[Kn Client issue] tracking eventing integration
* [[eventing-ux-issue]] https://github.com/knative/eventing/issues/1381[Kn Eventing issue] tracking UI/UX
* [[eventing-ux-scenarios]] https://docs.google.com/document/d/1DpiSL2dUcYS2n7yXOIG5LJwyIC1lY9q_W8-56U1SvKM/edit?hl=en#[Scenarios for Knative Eventing]

== Glossar

event topology:: The concrete setup with importers, channels and brokers as it can be used by _Developers_
custom type:: Type of channels and importers which are outside the set of well-known types
channel plugin:: A clientside plugin for a channel with a custom type
